// Полностью автоматическая система отслеживания покупок
import { logger } from './logger';
import { supabase } from './supabase';

interface AutoPurchase {
  id: string;
  buyerId: string;
  sellerId: string;
  productId: string;
  price: number;
  status: 'initiated' | 'completed';
  createdAt: string;
  completedAt?: string;
}

interface AutoReview {
  id: string;
  purchaseId: string;
  buyerId: string;
  sellerId: string;
  productId: string;
  rating: number;
  text: string;
  autoGenerated: boolean; // Автоматически сгенерированный
  createdAt: string;
}

class AutoPurchaseTracking {
  private static instance: AutoPurchaseTracking;

  private constructor() {}

  static getInstance(): AutoPurchaseTracking {
    if (!AutoPurchaseTracking.instance) {
      AutoPurchaseTracking.instance = new AutoPurchaseTracking();
    }
    return AutoPurchaseTracking.instance;
  }

  // Покупка - просто нажал кнопку "Купить"
  async createPurchase(buyerId: string, sellerId: string, productId: string, price: number): Promise<AutoPurchase> {
    try {
      const purchase: AutoPurchase = {
        id: crypto.randomUUID(),
        buyerId,
        sellerId,
        productId,
        price,
        status: 'initiated',
        createdAt: new Date().toISOString()
      };

      const { data, error } = await supabase
        .from('purchases')
        .insert(purchase)
        .select()
        .single();

      if (error) throw error;

      // Сразу завершаем покупку (автоматически)
      await this.completePurchase(data.id);

      logger.log('Auto purchase created and completed:', data.id);
      return data;
    } catch (error) {
      logger.error('Error creating auto purchase:', error);
      throw error;
    }
  }

  // Автоматическое завершение покупки
  private async completePurchase(purchaseId: string): Promise<void> {
    try {
      const { error } = await supabase
        .from('purchases')
        .update({
          status: 'completed',
          completedAt: new Date().toISOString()
        })
        .eq('id', purchaseId);

      if (error) throw error;

      // Обновляем статистику
      const purchase = await this.getPurchase(purchaseId);
      if (purchase) {
        await this.updateSalesStats(purchase);
        
        // Создаем автоматический отзыв через 5 минут
        setTimeout(() => {
          this.createAutoReview(purchaseId);
        }, 5 * 60 * 1000); // 5 минут
      }

      logger.log('Auto purchase completed:', purchaseId);
    } catch (error) {
      logger.error('Error completing auto purchase:', error);
    }
  }

  // Автоматический отзыв через 5 минут
  private async createAutoReview(purchaseId: string): Promise<void> {
    try {
      const purchase = await this.getPurchase(purchaseId);
      if (!purchase) return;

      // Генерируем случайный отзыв 4-5 звезд
      const rating = Math.random() > 0.3 ? 5 : 4;
      
      const reviewTexts = {
        5: [
          'Отличный товар! Все соответствует описанию.',
          'Продавец молодец! Быстрая доставка, качественный товар.',
          'Супер! Все понравилось, буду заказывать еще.',
          'Идеально! Товар в отличном состоянии, продавец надежный.',
          'Простос! Рекомендую этого продавца.'
        ],
        4: [
          'Хороший товар, соответствует описанию.',
          'Все нормально, доставка быстрая.',
          'Товар хороший, спасибо продавцу.',
          'Все отлично, рекомендую.',
          'Хороший выбор, доволен покупкой.'
        ]
      };

      const text = reviewTexts[rating][Math.floor(Math.random() * reviewTexts[rating].length)];

      const review: AutoReview = {
        id: crypto.randomUUID(),
        purchaseId,
        buyerId: purchase.buyerId,
        sellerId: purchase.sellerId,
        productId: purchase.productId,
        rating,
        text,
        autoGenerated: true,
        createdAt: new Date().toISOString()
      };

      const { error } = await supabase
        .from('reviews')
        .insert(review);

      if (error) throw error;

      // Обновляем рейтинги
      await this.updateRatings(purchase.productId, purchase.sellerId);

      logger.log('Auto review created:', review.id);
    } catch (error) {
      logger.error('Error creating auto review:', error);
    }
  }

  // Ручной отзыв (если пользователь захочет оставить свой)
  async createManualReview(
    purchaseId: string, 
    buyerId: string, 
    rating: number, 
    text: string
  ): Promise<AutoReview> {
    try {
      const purchase = await this.getPurchase(purchaseId);
      if (!purchase || purchase.buyerId !== buyerId) {
        throw new Error('Покупка не найдена');
      }

      // Проверяем, есть ли уже отзыв
      const existingReview = await this.getReviewByPurchase(purchaseId);
      if (existingReview) {
        throw new Error('Отзыв уже оставлен');
      }

      const review: AutoReview = {
        id: crypto.randomUUID(),
        purchaseId,
        buyerId,
        sellerId: purchase.sellerId,
        productId: purchase.productId,
        rating,
        text,
        autoGenerated: false,
        createdAt: new Date().toISOString()
      };

      const { data, error } = await supabase
        .from('reviews')
        .insert(review)
        .select()
        .single();

      if (error) throw error;

      // Обновляем рейтинги
      await this.updateRatings(purchase.productId, purchase.sellerId);

      logger.log('Manual review created:', data.id);
      return data;
    } catch (error) {
      logger.error('Error creating manual review:', error);
      throw error;
    }
  }

  // Получение покупки
  private async getPurchase(purchaseId: string): Promise<AutoPurchase | null> {
    try {
      const { data, error } = await supabase
        .from('purchases')
        .select('*')
        .eq('id', purchaseId)
        .single();

      if (error && error.code !== 'PGRST116') throw error;
      return data;
    } catch (error) {
      logger.error('Error getting purchase:', error);
      return null;
    }
  }

  // Получение отзыва по покупке
  private async getReviewByPurchase(purchaseId: string): Promise<AutoReview | null> {
    try {
      const { data, error } = await supabase
        .from('reviews')
        .select('*')
        .eq('purchaseId', purchaseId)
        .single();

      if (error && error.code !== 'PGRST116') throw error;
      return data;
    } catch (error) {
      logger.error('Error getting review by purchase:', error);
      return null;
    }
  }

  // Получение отзывов товара
  async getProductReviews(productId: string): Promise<AutoReview[]> {
    try {
      const { data, error } = await supabase
        .from('reviews')
        .select('*')
        .eq('productId', productId)
        .order('createdAt', { ascending: false });

      if (error) throw error;
      return data || [];
    } catch (error) {
      logger.error('Error getting product reviews:', error);
      return [];
    }
  }

  // Получение отзывов продавца
  async getSellerReviews(sellerId: string): Promise<AutoReview[]> {
    try {
      const { data, error } = await supabase
        .from('reviews')
        .select('*')
        .eq('sellerId', sellerId)
        .order('createdAt', { ascending: false });

      if (error) throw error;
      return data || [];
    } catch (error) {
      logger.error('Error getting seller reviews:', error);
      return [];
    }
  }

  // Обновление статистики продаж
  private async updateSalesStats(purchase: AutoPurchase): Promise<void> {
    try {
      // Обновляем статистику товара
      await supabase.rpc('increment_product_sales', {
        p_product_id: purchase.productId,
        p_amount: purchase.price
      });

      // Обновляем статистику продавца
      await supabase.rpc('increment_seller_sales', {
        p_seller_id: purchase.sellerId,
        p_amount: purchase.price
      });
    } catch (error) {
      logger.error('Error updating sales stats:', error);
    }
  }

  // Обновление рейтингов
  private async updateRatings(productId: string, sellerId: string): Promise<void> {
    try {
      // Получаем все отзывы товара
      const { data: reviews, error } = await supabase
        .from('reviews')
        .select('rating')
        .eq('productId', productId);

      if (error || !reviews || reviews.length === 0) return;

      const averageRating = reviews.reduce((sum, r) => sum + r.rating, 0) / reviews.length;

      // Обновляем рейтинг товара
      await supabase
        .from('product_market')
        .update({ rating: averageRating })
        .eq('id', productId);

      // Обновляем рейтинг продавца
      const sellerReviews = await this.getSellerReviews(sellerId);
      if (sellerReviews.length > 0) {
        const sellerAvgRating = sellerReviews.reduce((sum, r) => sum + r.rating, 0) / sellerReviews.length;
        
        await supabase
          .from('sellers')
          .update({ rating: sellerAvgRating })
          .eq('id', sellerId);
      }
    } catch (error) {
      logger.error('Error updating ratings:', error);
    }
  }

  // Получение покупок пользователя
  async getUserPurchases(buyerId: string): Promise<AutoPurchase[]> {
    try {
      const { data, error } = await supabase
        .from('purchases')
        .select('*')
        .eq('buyerId', buyerId)
        .order('createdAt', { ascending: false });

      if (error) throw error;
      return data || [];
    } catch (error) {
      logger.error('Error getting user purchases:', error);
      return [];
    }
  }

  // Получение покупок продавца
  async getSellerPurchases(sellerId: string): Promise<AutoPurchase[]> {
    try {
      const { data, error } = await supabase
        .from('purchases')
        .select('*')
        .eq('sellerId', sellerId)
        .order('createdAt', { ascending: false });

      if (error) throw error;
      return data || [];
    } catch (error) {
      logger.error('Error getting seller purchases:', error);
      return [];
    }
  }

  // Получение статистики
  async getStats(): Promise<{
    totalPurchases: number;
    completedPurchases: number;
    totalRevenue: number;
    totalReviews: number;
    autoReviews: number;
    manualReviews: number;
    averageRating: number;
  }> {
    try {
      const { data: purchases, error } = await supabase
        .from('purchases')
        .select('status, price');

      if (error) throw error;

      const totalPurchases = purchases?.length || 0;
      const completedPurchases = purchases?.filter(p => p.status === 'completed').length || 0;
      const totalRevenue = purchases?.reduce((sum, p) => sum + p.price, 0) || 0;

      const { data: reviews, error: reviewsError } = await supabase
        .from('reviews')
        .select('rating, autoGenerated');

      if (reviewsError) throw reviewsError;

      const totalReviews = reviews?.length || 0;
      const autoReviews = reviews?.filter(r => r.autoGenerated).length || 0;
      const manualReviews = totalReviews - autoReviews;
      const averageRating = totalReviews > 0 
        ? reviews.reduce((sum, r) => sum + r.rating, 0) / totalReviews 
        : 0;

      return {
        totalPurchases,
        completedPurchases,
        totalRevenue,
        totalReviews,
        autoReviews,
        manualReviews,
        averageRating: Math.round(averageRating * 10) / 10
      };
    } catch (error) {
      logger.error('Error getting stats:', error);
      return {
        totalPurchases: 0,
        completedPurchases: 0,
        totalRevenue: 0,
        totalReviews: 0,
        autoReviews: 0,
        manualReviews: 0,
        averageRating: 0
      };
    }
  }
}

export default AutoPurchaseTracking.getInstance();
